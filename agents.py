# agents.py
"""Module: agents.py
Description: Contains definitions for specialized storytelling agents.
Each agent uses a Mistral-based language model to generate text for a fantasy narrative.
Agents: PlotAgent, CharacterAgent, DialogueAgent, FactCheckerAgent.
"""
from ctransformers import AutoModelForCausalLM
import random

# global model
shared_model = None

# Stub templates with fantasy terms and proper nouns
STUB_SNIPPETS = {
    "PlotAgent": [
        "The kingdom of Eldoria was on the brink of collapse as the crimson dragon returned.",
        "High atop the obsidian cliffs, the prophecy was finally fulfilled.",
        "An ancient sword shimmered in the moonlight, revealing the truth of the heir."
    ],
    "CharacterAgent": [
        "Alarion, a brooding elf with silver eyes and a cursed lineage, emerged from the shadows.",
        "Seraphina, born of flame and storm, wielded magic none could match.",
        "Kael the Whisperer, cloaked in midnight, spoke with the voice of the dead."
    ],
    "DialogueAgent": [
        "\"We must reach the Crystal Spire before the eclipse,\" Alarion said, eyes blazing.",
        "\"You betrayed the realm for power,\" Seraphina hissed, her blade drawn.",
        "\"The ancient ones still walk among us,\" Kael warned under his breath."
    ]
}

class BaseAgent:
    def __init__(self, name: str, max_new_tokens: int = 100, use_stub: bool=False):
        global shared_model
        self.name = name
        self.max_new_tokens = max_new_tokens
        self.use_stub = use_stub

        if not self.use_stub and shared_model is None:
            print(f"Loading quantized Mistral model (shared) for all agents ...")
            shared_model = AutoModelForCausalLM.from_pretrained(
                "./models",
                model_file="mistral-7b-instruct-v0.1.Q4_K_M.gguf",
                model_type="mistral",
                gpu_layers=32
            )
        self.generator = shared_model

    def generate_text(self, prompt: str, **gen_kwargs) -> str:
        if self.use_stub:
            return random.choice(STUB_SNIPPETS.get(self.name, [f"[STUB TEXT GENERATED by {self.name}]"]))
        
        # Truncate to 512 tokens
        if hasattr(self.generator, "tokenize"):
            tokens = self.generator.tokenize(prompt)
            tokens = tokens[-512:]  # Keep only the last 512 tokens
            prompt = self.generator.detokenize(tokens)

        # Generate output with repetition penalty and temperature
        output = self.generator(
            prompt,
            max_new_tokens=self.max_new_tokens,
            temperature=0.7,
            repetition_penalty=1.15,
            **gen_kwargs
        )

        # Stop at markers like THE END or double newlines
        text = output.strip()
        for stop in ["THE END.", "\n\n", "###"]:
            if stop in text:
                text = text.split(stop)[0].strip() + " " + stop
                break

        return text


class PlotAgent(BaseAgent):
    """Agent responsible for contributing overarching plot points and narrative events."""
    def __init__(self, **kwargs):
        super().__init__(name="PlotAgent", max_new_tokens=150, **kwargs)
    def contribute(self, story_so_far: str) -> str:
        if story_so_far.strip() == "":
            prompt = "In a distant magical realm, where dragons soared and ancient secrets whispered through the forests, a tale began.\n\n[Plot] What happens next?"
        else:
            prompt = story_so_far.strip()
            prompt += "\n\nWrite the next scene in vivid detail, continuing the fantasy adventure:"
        return self.generate_text(prompt)



class CharacterAgent(BaseAgent):
    """Agent responsible for character development and introductions."""
    def __init__(self, **kwargs):
        super().__init__(name="CharacterAgent", **kwargs)

    def contribute(self, story_so_far: str, characters: list = None) -> str:
        prompt = story_so_far.strip()
        if characters:
            focus_char = characters[0]
            prompt += f"\n[Character] Describe {focus_char}  in rich fantasy detail â€” appearance, background, magical abilities, and motives: "
        else:
            prompt += "\n[Character] Introduce a new fantasy character with a mysterious backstory, magical traits, and distinct personality: "
        return self.generate_text(prompt)


class DialogueAgent(BaseAgent):
    """Agent responsible for generating dialogue between characters."""
    def __init__(self, **kwargs):
        super().__init__(name="DialogueAgent", **kwargs)

    def contribute(self, story_so_far: str, characters: list = None) -> str:
        prompt = story_so_far.strip()

        if characters and len(characters) >= 2:
            char1, char2 = characters[0], characters[1]
            prompt += (
                f"\n\n[Dialogue] In the moonlit ruins of Eldoria, {char1} and {char2} speak softly beneath the stars.\n"
                f"{char1}: "
            )
        elif characters:
            char1 = characters[0]
            prompt += (
                f"\n\n[Dialogue] Alone beneath the ancient trees, {char1} whispers into the night.\n"
                f"{char1}: "
            )
        else:
            prompt += (
                "\n\n[Dialogue] A mysterious voice echoes from the shadows of a forgotten temple:\n"
                "Unknown: "
            )

        return self.generate_text(prompt)


class FactCheckerAgent(BaseAgent):
    def __init__(self, **kwargs):
        super().__init__(name="FactCheckerAgent", **kwargs)
        self.known_facts = {}

    def check_consistency(self, new_text: str, story_so_far: str) -> tuple:
        if self.use_stub:
            issues = []
            text = new_text.strip()

            import re
            pattern = r'([A-Z][a-z]+) (?:is|was|has) ([^\\.]+)'
            matches = re.findall(pattern, text)
            for name, statement in matches:
                if name not in self.known_facts:
                    self.known_facts[name] = {}
                trait_words = statement.strip().split()
                if not trait_words:
                    continue
                if trait_words[0].lower() == "not":
                    if len(trait_words) >= 2:
                        trait_key = trait_words[1]
                        trait_val = "NOT"
                    else:
                        continue
                else:
                    trait_key = trait_words[0]
                    trait_val = " ".join(trait_words[1:])
                if trait_key in self.known_facts[name]:
                    old_val = self.known_facts[name][trait_key]
                    if trait_val.lower() != old_val.lower():
                        issues.append(f"Contradiction: {name}'s {trait_key} was {old_val}, now {trait_val}.")
                self.known_facts[name][trait_key] = trait_val

            death_matches = re.findall(r'([A-Z][a-z]+) (?:died|was killed)', text)
            for name in death_matches:
                if name not in self.known_facts:
                    self.known_facts[name] = {}
                self.known_facts[name]["dead"] = True

            for name, facts in self.known_facts.items():
                if facts.get("dead") == True and name in text:
                    issues.append(f"Inconsistency: {name} appears after being dead.")

            is_consistent = len(issues) == 0
            return is_consistent, issues

        prompt = (
            f"Does the following passage introduce any contradictions or inconsistencies "
            f"compared to the story so far?\n\nStory so far:\n{story_so_far}\n\nNew segment:\n{new_text}\n\n"
            f"List inconsistencies if any, otherwise say NONE."
        )
        output = self.generate_text(prompt)
        if "NONE" in output.upper():
            return True, []
        issues = output.split("\n")
        return False, [i for i in issues if i.strip()]
